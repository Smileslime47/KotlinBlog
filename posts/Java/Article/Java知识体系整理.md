# Java知识体系整理
## 基本问题
### Java特点
- 面向对象
- 平台无关
- 安全可靠
- 网络编程友好
- 多线程编程
- 编译与解释并存

### JVM/JRE/JDK
JVM：运行平台
JRE：基本运行环境，包含JVM
JDK：开发者套件，包含JRE

### 字节码好处
只对虚拟机负责，具体的实现交由不同平台的虚拟机负责，平台无关，可移植性好，解释执行效率高

### 编译与解释并存
Java代码->Class字节码：Java编译器
Class字节码->机器代码：JVM解释器（JIT缓存）

### 与C++区别
- Java没有指针，基本不涉及内存操作
- Java有GC，不需要管理内存释放
- Java只能实现多接口，没有多继承
- Java不能运算符重载

### 面向对象
- 多态，继承，封装
  - 多态：一个父类可以有多个子类实现，通过override覆写父类方法
  - 继承：子类可以继承父类，共享属性和方法并进行扩展
  - 封装：可以设置private和public，向外界隐瞒不必要的细节
- Overrride和Overload

### 接口和抽象类
- 共同点：都不能直接实例化，都有抽象方法
- 不同点：
  - 接口是对行为的规范，而抽象类的继承仍然是定义的扩展，是A is B
  - 接口可以多实现，抽象类不能多继承
  - 接口的成员变量是static final的，而抽象类的成员变量和类一样

### 基本数据类型
6种数字类型、char型和boolean

### 包装类型
与基本数据类型的区别：
- 存储空间：包装在堆，基本数据类型要视具体情况
- 大小：包装类型是类，空间更大
- 包装类型支持泛型


享元机制：
- 数字类型的包装在[-128,127]之间具有缓存机制，相同的值返回同一个对象
- 字符类型在[0,127]之间

自动装/拆：
- XXXX.valueOf方法

### 局部变量和成员变量
- 成员变量属于类的一部分，存储在堆中，生命周期跟随对象，可以不初始化
- 局部变量属于方法的一部分，存储在虚拟机栈中，生命周期跟随方法，需要初始化

### 静态变量和方法
属于Class对象的一部分，由所有实例对象共享，无法得知需要传入哪个实例对象因此不能直接调用实例方法

### String和char
- 一个是对象，一个是类
- char是一个整数型数据，而String引用指向一个String对象的地址

### 对象默认的零参构造器

### 深拷贝和浅拷贝

### ==和equals()方法的区别
==比较地址，equals根据具体覆写实现比较对象内容
### equals()和hashcode()的区别
equals()仅返回两个对象的内容是否相等，而hashcode根据内容计算出一个尽量唯一的散列值，用于定位哈希表位置
- hashcode相等不一定对象相等，还要考虑到哈希冲突
- 若equals相等则说明对象相等，存在重复key
- 若equals不等则说明哈希冲突，拉链法存入链表/红黑树

### String、StringBuilder和StringBuffer
String是不可变对象
- 表层：String和内部的value字段都是final的，无法被覆写
- 内层：如果修改了value会影响字符串常量池的映射逻辑

String调用+本质是创建一个StringBuilder
- StringBuilder是线程不安全的，性能稍好
- StringBuffer是线程安全的，性能稍差

每次调用+都会创建一个新的StringBuilder，因此直接调用StringBuilder性能会优于+

String通过字面量赋值直接返回字符串常量池的对象，而通过new则会先在字符串常量池创建再在堆创建
- 无论通过哪种赋值，intern方法都会返回字符串常量池的对象

### 注解，注解的解析方法
一种特殊的注释，会根据retention不同存储在Class对象中，可以被编译器和框架通过反射等方式读取，从而指示编译器或者框架的运行
- 编译期扫描，运行时扫描

### 反射及其优缺点
通过static的Class或者实例的getClass方法获取Class对象，并获取Field、Method等类的元数据
- 优点：获取类的元数据并进行操作，是许多框架IoC、动态代理的基础
- 缺点：安全性问题

## 异常处理
### Exception和Error的区别
excpetion可以被处理，而error会导致线程终止
### Checked和Unchecked（RuntimeException）区别
前者必须被处理，后者在运行时可能被抛出
### try-catch-finally
### try-with-resources

