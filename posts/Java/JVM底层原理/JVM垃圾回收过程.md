# JVM垃圾回收过程
关于[对象的生命周期](./%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%8F%AF%E5%9B%9E%E6%94%B6%E6%80%A7%E5%88%A4%E6%96%AD.md)在这篇文章中阐述

## 垃圾回收算法
---

### 标记-清除算法

标记-清除算法（Mark-and-Sweep）是最基础的GC算法，后续算法主要是该算法基础上的改进，主要分为两个步骤
- 标记堆中可被回收的对象
- 统一对被标记的对象的内存空间进行回收

该算法主要有**效率较低**、**内存中碎片空间过多**的缺点

### 标记-复制算法
复制（Copying）算法将内存分为两半，每次所有对象存放在其中一半
- 在标记-清除的基础上，每次清除完毕后将所有存活对象**转移到另一半内存空间中**，然后把原先一侧的空间清空

复制算法解决了内存碎片空间过多的问题，每次堆中的对象都集中在内存的其中一侧，但是也导致了**内存空间减半**的缺点，此外过多的复制操作也不适用于**老年代**这种数量较多的对象

### 标记-整理算法
标记-整理（Mark-and-Compact）算法是适用于**老年代**的一种回收算法
- 由于对象的大小都是8byte的整数倍，每次回收完后我们可以以堆空间的一端为边界将所有对象**推到一侧**，将堆空间整理为**存活对象和可用空间**两部分

标记-整理算法提高了内存空间的使用效率，但是同样因为转移操作较多导致效率较低，适用于**老年代**这种回收操作较少的对象

### 分代收集算法
JVM会根据不同的年龄分代采用适当的垃圾回收算法
- 对于新生代而言，存活对象的数量较少，适用于复制算法
- 对于老年代而言，存活数量较多但是存活几率高，适用于清除/整理算法

### 三色标记算法
对于早期的可达性分析算法采用一次性的**标记-清除**，但是因为会导致STW，性能低下，现在CMS GC和G1 GC更多采用**三色标记**算法：
  
三色标记将对象分为三类：
- Black：已经被扫描的过的对象，且该对象调用的其他对象也被扫描完毕
- Grey：已经被扫描过的对象，但该对象调用的其他对象还没被扫描完毕
- White：未被扫描过的对象

三色标记算法主要分为四个步骤：
- 初始标记：将GC Root直接调用过的所有节点全部标记为**灰色**，这部分会导致STW
- 并发标记：从灰色节点开始搜索他们调用的节点，并将其标记为**黑色**，这部分不会导致STW
- 重新标记：矫正那些并发标记中的错误，需要STW
- 并发清楚：将确定为White的节点清除掉，不需要STW

## 不同的垃圾收集器
---
### Serial收集器
Serial收集器是最早版本的GC，采用**新生代：标记-复制，老年代：标记-整理**的算法，在垃圾收集过程中需要全程Stop The World

### ParNew收集器
ParNew收集器是Seial收集器的**多线程版本**，同样采用**新生代：标记-复制，老年代：标记-整理**的算法，但是在垃圾收集过程中同样需要全程Stop The World

### Parallel收集器
Parallel收集器是优化性能版本的ParNew收集器，它更注重**CPU的利用效率**而非**用户线程的使用体验**

### CMS收集器
CMS收集器更注重用户进程的体验，是真正意义上的**并发GC**，采用了**三色标记的标记清除算法**，有并发收集，停顿时间小的优点

缺点是采用标记清楚算法会导致内存中有许多空间碎片产生

### G1收集器